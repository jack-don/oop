<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>內建对象</title>
	</head>
	<body>
		<script>
			/*
			 创建对象
			 * 第一个是执行对象文本标识法，第二种是object构造器函数。
			 * 无论多么复杂的对象都继承自object，并且拥有其所有方法。
			 * */
//			var o={}
//			var o=new Object()
			
			/*
			 valueOf toString
			 *  valueOf 返回对象的原始值（对象自己）;
			 * 	toString 需要用字符串来表示对象的时候被js在内部调用；如alert；
			 * */
//			alert(o.valueOf()===o)
//			var o={1,12};
//			alert(o)

			/*
			 Array
			 *  可以用构建数组的內建构造器函数，或数组文本标识法来创建。
			 * */
			//下面两个是等效的
//			var a=new Array();
//			var a=[];
			//传给构造器的数字5会被认为是数组的长度。
//			var a2=new Array(5)
			
			/*
			 数组的方法
			 * push()方法会在数组的末端添加一个新元素。a.push("new")相当于a[a.length]="new"。返回的是改变后数组长度；
			 * pop()方法则会移除最后一个元素。a.pop()则与a.length--的结果相同。返回的则是被移除的元素；
			 * sort()用于数组排序的，它返回修改后的数组。
			 * join()返回一个由目标数组中所有元素值链接而成的字符串，还可以通过该方法的参数设定这些元素之间的字符串。
			 * slice()在不修改目标数组的情况下返回其中某个片段，该片段首尾索引位置由slice()的头两个参数来定（都以0为基数）
			 * 		slice()的第一个参数的索引是包含对应的值，第二个参数的对应的值是不被包含的。
			 * splice()会修改目标数组，会移除并返回指定切片，并且在可选情况下，还会用指定的新元素来填补被切除的空缺。该方法
			 * 		头两个参数所指定的是要移除切片的首尾索引位置，其它参数是用于填补新的元素值。
			 * 		首索引位置起始为0，从左侧计数包含首尾索引对应的值。
			 * */
//			var a=[3,2,1];
//			a.push("new")
//			alert(a.push("new"))
//			alert(a.pop())
//			var b=a.sort();
//			var arrJoin=a.join(" xige ");
//			alert(typeof arrJoin);
//			alert(a.slice(0,2))
//			var c=a.splice(0,1,11,22,33,44)
//			alert(a)

			/*
			 function
			 * 避免用function构造器来创建函数，这样需要通过参数来设定函数的参数名及函数体中的代码（都是字符串），js引擎会对这些源代码进行解析
			 * 		因为js引擎无法检查字符串中的内容。
			 * length属性，记录该函数所拥有参数的数量。
			 * caller属性，是ecma标准之外的属性，对于浏览器来说非常重要，其会返回一个调用该函数对象的外层函数引用。在函数B()中调用A()，那么
			 * 		只要在A()中调用A.caller 。结果就会返回函数B()。如果希望自己的函数能根据其调用函数做出不同的反应时，该属性会很重要。
			 * 函数对象还有两个常用的方法：call() ,apply().通过这两个方法能让对象去借用其他对象中的方法，为己用。
			 * arguments对象的callee属性，该属性引用的是当前被调用的函数对象，也就是所建函数的返回值是arguments.callee那么该函数在被调用时就
			 * 		会返回自身的引用
			 * 		
			 * */
			//下面三种定义函数的方式是等效的
//			function sum(){};
//			var sum=function(){};
//			var sum=new Function();

			//函数caller属性
//			function A(){return A.caller;}
//			function B(){return A();}
//			alert(B())
			//全局域调用A()的 A.caller的值就会为null。
			
			//call() apply()  让my_obj也具有say方法
//			var some_obj={say:function(){alert("0");}};
//			var my_obj={name:"xige"};
//			some_obj.say.call(my_obj,"dude")

			//callee
//			function f(){return arguments.callee;}
//			alert(f());
			//利用这个属性写递归
//			(function(conut){
//				if(conut<5){
//					alert(conut);
//					arguments.callee(++conut)
//				}
//			})(1)
			
			/*
			 string			 
			 * toUpperCase(); toLowerCase(); 大小写转换。
			 * chartAt(),返回的是我们指定位置的字符串，与中括号位置相当的。如果位置不存在，就会返回一个空字符串。
			 * indexOf() 遇到匹配的字符时会返回第一次匹配位置的索引值，由于该索引值从0开始计数，所以字符couch中
			 * 		的第二个字符o的位置索引值为1。还可以指定参数指定搜索开始的位置（已索引值的形式）。
			 * lastIndexOf() 从末尾开始检索方法与indexOf()的一样。
			 * slice() substring() 都可以用于返回目标字符串中指定的区间。两个参数第一个参数的索引值是被包裹的而
			 * 		第二个参数的索引值是不被包括在内的。两个不同之处对负值的处理 slice()方法会将它与字符串长度想加
			 * 		substring()会将它视为从0开始计数。如（1，-1） slice（1，s.length-1）substring（1,0）
			 * split() 可以依据我们所传递的分割字符串，将目标字符串分割成一个数组。
			 * join() 会将一个数组合并成一个字符串
			 * concat()常用语追加字符串。
			 * */
			
//			var s=new String("xig ege");
//			s.indexOf("i");
//			alert(s.indexOf("e",4))
//			alert(s.split(" "))
//			alert(s.split(" ").join(" "))
//			alert(s.concat("董振"))

			/*
			 math
			 * random() 返回的是从0到1之间的某个数。如果想从0到100间获得可以这样写 100*Math.random()。
			 * 		((max-min)*Math.random())+min  获取某个max和min之间的值。
			 * floor() 用于舍弃  ceil()用于取人  round() 四舍五入
			 * */


		</script>
	</body>
</html>
